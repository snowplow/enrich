name: sync-public-main

on:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  PUBLIC_REPO_MAIN: master
  PUBLIC_REPO_URL: https://github.com/snowplow/enrich
  SYNC_BRANCH: public-main

jobs:
  sync:
    if: ${{ github.event.repository.private == true }}
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout private repo (${{ env.SYNC_BRANCH }})
        uses: actions/checkout@v4
        with:
          ref: ${{ env.SYNC_BRANCH }}
          fetch-depth: 0
          persist-credentials: false

      - name: Generate GitHub App Token for Snowplow Incubator Org
        id: generate_token
        run: |
          echo "Using Snowplow Incubator org token"
          echo "installation_id=${{ secrets.GH_APP_INSTALLATION_ID }}" >> "$GITHUB_OUTPUT"

      - name: Generate GitHub App Token
        id: auth_token
        uses: tibdex/github-app-token@v1
        with:
          app_id: ${{ secrets.GH_APP_ID }}
          private_key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          installation_id: ${{ steps.generate_token.outputs.installation_id }}

      - name: Add public repo as remote
        run: |
          REPO_PATH="${PUBLIC_REPO_URL#https://}"
          git remote add public-origin https://x-access-token:${{ steps.auth_token.outputs.token }}@$REPO_PATH
          git fetch public-origin

      - name: Fast-forward merge to main
        run: |
          git checkout public-origin/${{ env.PUBLIC_REPO_MAIN }}
          git merge --ff-only ${{ env.SYNC_BRANCH }}

      - name: Push Changes to Public Repo
        run: |
          if ! git push public-origin ${{ env.SYNC_BRANCH }}:${{ env.PUBLIC_REPO_MAIN }}; then
            echo "Push failed; check for conflicts or diverged branches."
            exit 1
          fi

      - name: Push missing tags to Public Repo
        run: |
          TAGS_TO_PUSH=$(git tag --merged ${{ env.SYNC_BRANCH }} | grep -E '^[0-9]+(\.[0-9]+){1,2}$')
          echo "$TAGS_TO_PUSH" > /tmp/pushed_tags.txt
          for TAG in $TAGS_TO_PUSH; do
            git push public-origin $TAG || {
              echo "Push failed for tag $TAG; check for conflicts or invalid tag state."
            }
          done

      - name: Clone releases from private to public
        env:
          GH_TOKEN: ${{ steps.auth_token.outputs.token }}
        run: |
          PRIVATE_REPO="${{ github.repository }}"
          PUBLIC_REPO="${PUBLIC_REPO_URL#https://github.com/}"

          while IFS= read -r TAG; do
            [ -z "$TAG" ] && continue

            # Check if release exists in private repo
            if ! gh release view "$TAG" --repo "$PRIVATE_REPO" &>/dev/null; then
              continue
            fi

            echo "Found release for tag $TAG in private repo"

            # Get release metadata
            RELEASE_DATA=$(gh release view "$TAG" --repo "$PRIVATE_REPO" --json name,body,isDraft,isPrerelease)
            IS_DRAFT=$(echo "$RELEASE_DATA" | jq -r '.isDraft')
            IS_PRERELEASE=$(echo "$RELEASE_DATA" | jq -r '.isPrerelease')

            # Skip draft and prerelease (public is only for official releases)
            if [ "$IS_DRAFT" = "true" ] || [ "$IS_PRERELEASE" = "true" ]; then
              echo "Skipping non-official release for tag $TAG"
              continue
            fi

            # Check if release already exists in public repo
            if gh release view "$TAG" --repo "$PUBLIC_REPO" &>/dev/null; then
              echo "Release for tag $TAG already exists in public repo, skipping"
              continue
            fi

            # Extract metadata and write body to temp file (handles special characters)
            RELEASE_TITLE=$(echo "$RELEASE_DATA" | jq -r '.name // ""')
            NOTES_FILE=$(mktemp)
            echo "$RELEASE_DATA" | jq -r '.body // ""' > "$NOTES_FILE"

            # Create release in public repo
            echo "Creating release for tag $TAG in public repo..."
            gh release create "$TAG" --repo "$PUBLIC_REPO" --title "$RELEASE_TITLE" --notes-file "$NOTES_FILE"

            # Download and upload assets if any
            ASSET_DIR=$(mktemp -d)
            if gh release download "$TAG" --repo "$PRIVATE_REPO" --dir "$ASSET_DIR" 2>/dev/null; then
              for ASSET in "$ASSET_DIR"/*; do
                [ -f "$ASSET" ] && gh release upload "$TAG" "$ASSET" --repo "$PUBLIC_REPO" --clobber
              done
              echo "Uploaded assets for tag $TAG"
            fi

            # Cleanup
            rm -f "$NOTES_FILE"
            rm -rf "$ASSET_DIR"
            echo "Successfully synced release for tag $TAG"
          done < /tmp/pushed_tags.txt